from .api import FFI


MODULE_BOILERPLATE = """
#####                                                                  #####
##### NOTE: This module is generated by cffi. DO NOT EDIT IT MANUALLY. #####
#####                                                                  #####

from functools import wraps
from cffi import FFI


_ffi = FFI()


### The functions below are proxies for `_ffi` to make things more convenient.


@wraps(_ffi.typeof)
def typeof(cdecl):
    return _ffi.typeof(cdecl)


@wraps(_ffi.sizeof)
def sizeof(cdecl):
    return _ffi.sizeof(cdecl)


@wraps(_ffi.alignof)
def alignof(cdecl):
    return _ffi.alignof(cdecl)


@wraps(_ffi.offsetof)
def offsetof(cdecl):
    return _ffi.offsetof(cdecl)


@wraps(_ffi.new)
def new(cdecl, init=None):
    return _ffi.new(cdecl, init=init)


@wraps(_ffi.cast)
def cast(cdecl, source):
    return _ffi.cast(cdecl, source)


@wraps(_ffi.string)
def string(cdecl, maxlen=-1):
    return _ffi.string(cdecl, maxlen=-1)


@wraps(_ffi.buffer)
def buffer(cdecl, maxlen=-1):
    return _ffi.buffer(cdecl, maxlen=-1)


@wraps(_ffi.callback)
def callback(cdecl, python_callable=None, error=None):
    return _ffi.callback(cdecl, python_callable=python_callable, error=error)


@wraps(_ffi.getctype)
def getctype(cdecl, replace_with=''):
    return _ffi.getctype(cdecl, replace_with=replace_with)


@wraps(_ffi.gc)
def gc(cdata, destructor):
    return _ffi.gc(cdata, destructor)


def _get_errno():
    return _ffi.errno
def _set_errno(errno):
    _ffi.errno = errno
errno = property(_get_errno, _set_errno, None,
                 "the value of 'errno' from/to the C calls")


@wraps(_ffi.addressof)
def addressof(cdata, field=None):
    return _ffi.addressof(cdata, field=field)


@wraps(_ffi.new_handle)
def new_handle(x):
    return _ffi.new_handle(x)


@wraps(_ffi.from_handle)
def from_handle(x):
    return _ffi.from_handle(x)


### The functions below are generated by cffi.
"""


DLOPEN_FUNC_TEMPLATE = """
def load_%s():
    return _ffi.dlopen(%r, flags=%r)
"""


MAKELIB_FUNC_TEMPLATE = """
def load_%s():
    import os.path
    from cffi.verifier import Verifier
    module_path = os.path.dirname(__file__)
    verifier = Verifier(_ffi, None, module_path, %r, force_generic_engine=True)
    verifier._has_module = True
    return verifier._load_library()
"""


class FFIBuilder(object):
    def __init__(self, module_name, module_path, backend=None):
        self._module_name = module_name
        self._module_path = module_path
        self.ffi = FFI(backend=backend)
        self._built_files = []
        self._module_source = MODULE_BOILERPLATE

    def cdef(self, csource, override=False):
        self.ffi.cdef(csource, override=override)
        self._module_source += "_ffi.cdef(%r, override=%r)\n" % (
            csource, override)

    def add_dlopen(self, libname, name, flags=0):
        lib = self.ffi.dlopen(name, flags=flags)
        self._module_source += DLOPEN_FUNC_TEMPLATE % (libname, name, flags)
        return lib

    def makelib(self, libname, source='', **kwargs):
        # XXX: We use force_generic_engine here because vengine_cpy collects
        #      types when it writes the source.
        import os.path
        from .verifier import Verifier, _get_so_suffix
        self.ffi.verifier = Verifier(
            self.ffi, source, force_generic_engine=True, **kwargs)
        libfilename = '_'.join([self._module_name, libname])
        libfilepath = os.path.join(
            self._module_path, libfilename + _get_so_suffix())
        self.ffi.verifier.make_library(libfilepath)
        self._module_source += MAKELIB_FUNC_TEMPLATE % (libname, libfilename)
        self._built_files.append(libfilename + _get_so_suffix())

    def write_ffi_module(self):
        import os
        try:
            os.makedirs(self._module_path)
        except OSError:
            pass

        module_filename = self._module_name + '.py'
        module_filepath = os.path.join(self._module_path, module_filename)
        file = open(module_filepath, 'w')
        try:
            file.write(self._module_source)
        finally:
            file.close()
        self._built_files.append(module_filename)

    def list_built_files(self):
        return self._built_files
