import os
import pickle

from .api import FFI


MODULE_BOILERPLATE = """
#####                                                                  #####
##### NOTE: This module is generated by cffi. DO NOT EDIT IT MANUALLY. #####
#####                                                                  #####

import pickle
from cffi import FFI


_ffi = FFI()


### Proxy `_ffi` methods to make things more convenient.


typeof = _ffi.typeof
sizeof = _ffi.sizeof
alignof = _ffi.alignof
offsetof = _ffi.offsetof
new = _ffi.new
cast = _ffi.cast
string = _ffi.string
buffer = _ffi.buffer
callback = _ffi.callback
getctype = _ffi.getctype
gc = _ffi.gc


# Can't have properties on modules. :-(

def get_errno():
    return _ffi.errno

def set_errno(errno):
    _ffi.errno = errno


addressof = _ffi.addressof
new_handle = _ffi.new_handle
from_handle = _ffi.from_handle


### The functions below are generated by cffi.
"""


DLOPEN_FUNC_TEMPLATE = """
def load_%s():
    return _ffi.dlopen(%r, flags=%r)
"""


MAKELIB_FUNC_TEMPLATE = """
def load_%s():
    import os.path
    from cffi.verifier import Verifier
    module_path = os.path.dirname(__file__)
    verifier = Verifier(_ffi, None, module_path, %r, force_generic_engine=True)
    verifier._has_module = True
    return verifier._load_library()
"""


class FFIBuilder(object):
    def __init__(self, module_name, build_path, backend=None):
        module_package = ''
        if '.' in module_name:
            module_package, module_name = module_name.rsplit('.', 1)
        self._module_package = module_package
        self._module_name = module_name
        self._build_path = build_path
        self.ffi = FFI(backend=backend)
        self._built_files = []
        self._module_source = MODULE_BOILERPLATE

    def _filename(self, name, suffix='.py'):
        parts = self._module_package.split('.')
        parts.append(name + suffix)
        return os.path.join(*parts)

    def cdef(self, csource, override=False):
        self.ffi.cdef(csource, override=override)

    def add_dlopen(self, libname, name, flags=0):
        lib = self.ffi.dlopen(name, flags=flags)
        self._module_source += DLOPEN_FUNC_TEMPLATE % (libname, name, flags)
        return lib

    def makelib(self, libname, source='', **kwargs):
        # XXX: We use force_generic_engine here because vengine_cpy collects
        #      types when it writes the source.
        kwargs['force_generic_engine'] = True
        from .verifier import Verifier, _get_so_suffix
        self.ffi.verifier = Verifier(self.ffi, source, **kwargs)
        barefilename = '_'.join([self._module_name, libname])
        libfile_path = self._filename(barefilename, _get_so_suffix())
        libfile_build_path = os.path.join(self._build_path, libfile_path)
        self.ffi.verifier.make_library(libfile_build_path)
        self._module_source += MAKELIB_FUNC_TEMPLATE % (libname, barefilename)
        self._built_files.append(libfile_path)

    def write_ffi_module(self):
        self._module_source += (
            "_ffi._parser._declarations = pickle.loads(%r)\n" %
            pickle.dumps(self.ffi._parser._declarations, 2))
        try:
            os.makedirs(self._build_path)
        except OSError:
            pass

        module_path = self._filename(self._module_name)
        module_build_path = os.path.join(self._build_path, module_path)
        file = open(module_build_path, 'w')
        try:
            file.write(self._module_source)
        finally:
            file.close()
        self._built_files.append(module_path)

    def list_built_files(self):
        return self._built_files
